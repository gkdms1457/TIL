---
title : reverse engineering basic
category :
    - reverse engineering
tag :
    - reversing
---

리버싱(reversing) - 리버스 엔지니어링(reverse engineering)

* 완성품의 구조와 기능, 동작 과정을 알아내는 모든 단계
    - 완성된 프로그램을 분석하여 소스 구조 파악하는 것
* 역공학 - 만들어져 있는 것을 해체하며 구조와 기능 알아내기
* 소프트웨어 구조 분석 -> 바이너리 분석결과 -> 내부 구조 파악 -> 원래 소스가 어떻게 작성된 것인지 알아냄

---
## 리버싱 사용 Good case
 * 개발 중단된 프로그램에 대한 지원 필요할 때
 * 보안성 평가, 악성코드 분석
    - 얼마나 안전하게 설계되었는지, 악성코드가 어떤 방식으로 동작하는지 알아냄

## 리버싱 사용 Bad case
 * 유료 프로그램 공짜로 이용하기위한 불법 프로그램
    - 키젠 프로그램, 시리얼넘버 생성기, 정품 크랙 (어떤식으로 정품 인증 하는지 알아냄)
 * 게임핵
 > 전체 작동원리 알 수 있어 -> 지적재산권 침해 -> 침해하지 않는 범위 내에서 제한적으로 사용해야한다.


## 리버싱 방법
 ### static analysis - 정적 분석 방법
  * 프로그램을 실행시키지 않고 분석
  * 어셈블리 코드 이해 필요
     - 기계어와 일대일 대응되는 프로그래밍 저급 언어
     - 실제로 컴퓨터의 CPU가 읽어 실행할 수 있는 0과 1로 이루어진 명령어 조합 -> 각 명령어에 대해 사람이 이해하기 쉬운 니모닉 기호(mnemonic symbol)를 정해 쉽게 컴퓨터의 행동을 제어할 수 있도록 함
 ### dynamic analysis - 동적 분석 방법
  * 프로그램 실행 -> 입출력과 내부 동작 분석
  * 단계별로 자세히 분석 -> 환경에 맞는 디버거로 단계별 분석 기술 이해 필요


## 코드가 컴파일되는 과정
 `컴파일?` 사람이 이해할 수 있는 소스 코드를 컴퓨터가 이해할 수 있는 형태인 바이너리(binary)코드로 바꾸는 과정

 1. 소스코드(source code)
    - 주석, 매크로, 헤더파일 포함하고 있음 -> 참조를 위해 붙여둔 정보
    - 컴파일러 : 모두 미리 처리 -> 다음단계 변환 준비
 2. 중간언어(intermediate language)
 3. 어셈블리코드(assembly code)
    - 컴파일러 : 중간언어를 분석, 최적화하여 어셈블리로 만들어줌
 4. binary code


## 분석가 - 컴파일 과정 역으로 진행
 1. binary code
    - 바이너리 코드를 어셈블리 코드로 변환
 2. 어셈블리코드(assembly code)
    - 어셈블리 분석 -> 대상 바이너리 작동과정 알아냄
 > binary에서 assemblely로 변환하는 과정 : `disassemble`
 3. 소스코드(source code)
 > 어셈블리 분석하여 소프트웨어 동작구조 알아내는 것 : `reversing`


## 어셈블리 코드
 기계코드와 일대일 대응 -> 실제 동작할  CPU에 따라 기계코드가 달라짐
 >  Intel 구조 64bit버전 명령어 집합(x64) - x64 명령어 집합(x84-64)


## CPU 동작과정 - 어셈블리 이해에 도움
 어셈블리 코드는 기계어와 일대일 대응 -> 기계코드 동작할 CPU의 역할과 작동방식 이해 -> 어셈블리 이해에 도움  
 동작 과정(1~3과정 반복, 1~3한번의 과정 : `instruction Cycle`)  
 1. 실행할 명령어 읽어옴(Fetch)
 2. 읽어온 명령어 해석(Decode)
 3. 해석한 결과 실행(Execute)


## Register - 레지스터
 CPU의 동작에 필수적인 저장 공간의 역할을 하는 CPU의 구성 요소, CPU가 사용하는 저장공간
 * 기계 코드에 해당하는 각종 명령어 해석위한 요소
 * 읽어온 명령어 저장된 공간 임시기억 요소
 * 명령어 실행 결과 저장해둘 요소

 ### 범용 레지스터(General-Purpose Register, GPR)
 특정 용도없이 다양하게 쓸 수 있는 레지스터, 연습장처럼 사용
 x64는 총 16개의 범용 레지스터 존재
 
 ```
 rax 
 rcx rdx r8 r9 
 r10 r11 rbx rsi rdi rbp r12 r13 r14 r15 
 rsp
 ```
 
 원칙적으로 쓰임이 정해져 있지 않지만, 관행적으로 정해져 있는 경우도 있음
 * rax - 함수 리턴값 저장에 쓰임  
   -> 함수 반환 전까지는 범용으로 자유롭게 쓰임
 * 함수 호출 규약(Calling Convention)
   - 함수가 실행될 때 필요한 인자들을 저장하는 용도의 레지스터
   - 운영체제나 함수의 종류마다 다름
   - Windows 64bit
      * rcx, rdx, r8, r9 - 함수 호출에 필요한 인자들을 순서대로 저장
 * rsp - 용도가 정해져 있는 레지스터, 스택포인터로 스택의 가장 위쪽 주소 가리킴


 `rip` - 명령어 포인터로 용도가 엄격히 정해져 있는 레지스터, 다음에 실행될 명령어가 위치한 주소를 가리키고 있음


 ### data size - CPU가 사용하는 값의 크기(WORD)
 `ax, cx, dx, bx - 초기 16bit CPU의 범용레지스터`  
 x64의 레지스터들이 담을 수 있는 값의 크기 : 64bit(8byte,QWORD)이지만  
 **rcx 레지스터**